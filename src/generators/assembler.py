"""Code assembly logic for combining templates and LLM-generated code."""

import io
import zipfile
from typing import Dict
from pathlib import Path


def assemble_client_class(base_template: str, endpoint_methods: str) -> str:
    """
    Assemble the complete client class by inserting endpoint methods.
    
    Args:
        base_template: Rendered client template with placeholder
        endpoint_methods: LLM-generated endpoint methods
        
    Returns:
        Complete client code
    """
    # Replace the placeholder with actual endpoint methods
    return base_template.replace("{{ endpoint_methods }}", endpoint_methods)


def assemble_types_file(generated_types: str) -> str:
    """
    Assemble the types file.
    
    Args:
        generated_types: LLM-generated TypeScript type definitions
        
    Returns:
        Complete types.ts content
    """
    header = """/**
 * TypeScript type definitions
 * Generated by API SDK Generator
 */

"""
    return header + generated_types


def assemble_example_file(api_name_class: str, package_name: str, example_code: str) -> str:
    """
    Assemble the example.ts file.
    
    Args:
        api_name_class: API client class name
        package_name: NPM package name
        example_code: LLM-generated example code
        
    Returns:
        Complete example.ts content
    """
    header = f"""/**
 * Usage examples
 * Generated by API SDK Generator
 */

import {{ {api_name_class} }} from './{package_name}';

"""
    return header + example_code


def create_file_structure(all_files: Dict[str, str]) -> Dict[str, str]:
    """
    Organize files into proper directory structure.
    
    Args:
        all_files: Dictionary of file paths to content
        
    Returns:
        Organized file structure
    """
    # Files are already organized with paths like "src/client.ts"
    # This function can add any additional organization if needed
    return all_files


def bundle_to_zip(file_structure: Dict[str, str], api_name: str) -> bytes:
    """
    Bundle all files into a ZIP archive.
    
    Args:
        file_structure: Dictionary mapping file paths to content
        api_name: API name for the root directory
        
    Returns:
        ZIP file as bytes
    """
    # Create sanitized directory name
    dir_name = api_name.lower().replace(" ", "-").replace("_", "-") + "-sdk"
    
    # Create in-memory ZIP file
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for file_path, content in file_structure.items():
            # Add root directory to path
            full_path = f"{dir_name}/{file_path}"
            
            # Write file to ZIP
            zip_file.writestr(full_path, content)
    
    # Get the ZIP bytes
    zip_buffer.seek(0)
    return zip_buffer.read()


def get_file_tree_display(file_structure: Dict[str, str]) -> str:
    """
    Create a visual file tree for display.
    
    Args:
        file_structure: Dictionary mapping file paths to content
        
    Returns:
        File tree as string
    """
    lines = []
    
    # Sort files for consistent display
    sorted_files = sorted(file_structure.keys())
    
    # Group by directory
    dirs = {}
    for file_path in sorted_files:
        parts = file_path.split('/')
        if len(parts) > 1:
            dir_name = '/'.join(parts[:-1])
            if dir_name not in dirs:
                dirs[dir_name] = []
            dirs[dir_name].append(parts[-1])
        else:
            if 'root' not in dirs:
                dirs['root'] = []
            dirs['root'].append(file_path)
    
    # Build tree
    for dir_name in sorted(dirs.keys()):
        if dir_name != 'root':
            lines.append(f"ðŸ“ {dir_name}/")
            for file_name in sorted(dirs[dir_name]):
                lines.append(f"  ðŸ“„ {file_name}")
        else:
            for file_name in sorted(dirs[dir_name]):
                lines.append(f"ðŸ“„ {file_name}")
    
    return '\n'.join(lines)


def calculate_total_size(file_structure: Dict[str, str]) -> int:
    """
    Calculate total size of all files in bytes.
    
    Args:
        file_structure: Dictionary mapping file paths to content
        
    Returns:
        Total size in bytes
    """
    return sum(len(content.encode('utf-8')) for content in file_structure.values())


def format_size(size_bytes: int) -> str:
    """
    Format size in human-readable format.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Formatted size string (e.g., "54.5 KB")
    """
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
