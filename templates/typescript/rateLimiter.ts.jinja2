/**
 * Rate limiter using token bucket algorithm for {{ api_name }} SDK
 * Generated by API SDK Generator
 */

export interface RateLimitConfig {
  requestsPerSecond: number;
  burstAllowance: number;
}

export const DEFAULT_RATE_LIMIT_CONFIG: RateLimitConfig = {
  requestsPerSecond: {{ rate_limit_config.requests_per_second }},
  burstAllowance: {{ rate_limit_config.burst_allowance }},
};

/**
 * Token bucket rate limiter
 */
export class RateLimiter {
  private tokens: number;
  private lastRefillTime: number;
  private readonly config: RateLimitConfig;
  private readonly refillRate: number; // tokens per millisecond
  private readonly queue: Array<() => void> = [];

  constructor(config: RateLimitConfig = DEFAULT_RATE_LIMIT_CONFIG) {
    this.config = config;
    this.tokens = config.burstAllowance;
    this.lastRefillTime = Date.now();
    this.refillRate = config.requestsPerSecond / 1000; // Convert to per millisecond
  }

  /**
   * Wait for a token to become available
   */
  async acquire(): Promise<void> {
    this.refillTokens();

    if (this.tokens >= 1) {
      this.tokens -= 1;
      return Promise.resolve();
    }

    // No tokens available, wait
    const waitTime = this.calculateWaitTime();
    await this.sleep(waitTime);
    
    // Try again after waiting
    return this.acquire();
  }

  /**
   * Refill tokens based on time elapsed
   */
  private refillTokens(): void {
    const now = Date.now();
    const timeSinceLastRefill = now - this.lastRefillTime;

    // Calculate tokens to add
    const tokensToAdd = timeSinceLastRefill * this.refillRate;

    // Add tokens, capped at burst allowance
    this.tokens = Math.min(
      this.tokens + tokensToAdd,
      this.config.burstAllowance
    );

    this.lastRefillTime = now;
  }

  /**
   * Calculate how long to wait for next token
   */
  private calculateWaitTime(): number {
    // Time to generate 1 token
    const timePerToken = 1000 / this.config.requestsPerSecond;
    
    // Need to wait for at least 1 token
    const tokensNeeded = 1 - this.tokens;
    
    return Math.ceil(tokensNeeded * timePerToken);
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Get current token count (for debugging)
   */
  getTokenCount(): number {
    this.refillTokens();
    return this.tokens;
  }

  /**
   * Reset the rate limiter
   */
  reset(): void {
    this.tokens = this.config.burstAllowance;
    this.lastRefillTime = Date.now();
  }
}

/**
 * Per-endpoint rate limiters
 */
export class PerEndpointRateLimiter {
  private limiters: Map<string, RateLimiter> = new Map();
  private globalLimiter: RateLimiter;

  constructor(
    globalConfig: RateLimitConfig = DEFAULT_RATE_LIMIT_CONFIG,
    private endpointConfigs: Map<string, RateLimitConfig> = new Map()
  ) {
    this.globalLimiter = new RateLimiter(globalConfig);
  }

  /**
   * Acquire token for a specific endpoint
   */
  async acquire(endpoint: string): Promise<void> {
    // Check endpoint-specific limiter first
    if (this.endpointConfigs.has(endpoint)) {
      const limiter = this.getOrCreateLimiter(endpoint);
      await limiter.acquire();
    }

    // Always check global limiter
    await this.globalLimiter.acquire();
  }

  /**
   * Get or create rate limiter for endpoint
   */
  private getOrCreateLimiter(endpoint: string): RateLimiter {
    if (!this.limiters.has(endpoint)) {
      const config = this.endpointConfigs.get(endpoint) || DEFAULT_RATE_LIMIT_CONFIG;
      this.limiters.set(endpoint, new RateLimiter(config));
    }
    return this.limiters.get(endpoint)!;
  }

  /**
   * Set rate limit for specific endpoint
   */
  setEndpointLimit(endpoint: string, config: RateLimitConfig): void {
    this.endpointConfigs.set(endpoint, config);
    // Reset limiter if it exists
    if (this.limiters.has(endpoint)) {
      this.limiters.delete(endpoint);
    }
  }
}
