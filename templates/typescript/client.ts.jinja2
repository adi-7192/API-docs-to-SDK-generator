/**
 * {{ api_name }} SDK Client
 * Generated by API SDK Generator
 */

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
{% if enable_retry_logic %}import { retryWithBackoff, RetryConfig, DEFAULT_RETRY_CONFIG, circuitBreaker } from './utils/retry';{% endif %}
{% if enable_rate_limiting %}import { PerEndpointRateLimiter, RateLimitConfig, DEFAULT_RATE_LIMIT_CONFIG } from './utils/rateLimiter';{% endif %}
import { Logger, LogLevel } from './utils/logger';
import { createErrorFromResponse, NetworkError } from './errors';

export interface SDKConfig {
  {% if auth_type == 'api_key' %}apiKey?: string;{% endif %}
  {% if auth_type == 'bearer' %}bearerToken?: string;{% endif %}
  {% if auth_type == 'oauth2' %}accessToken?: string;{% endif %}
  {% if auth_type == 'basic' %}username?: string;
  password?: string;{% endif %}
  baseURL: string;
  timeout?: number;
  {% if enable_retry_logic %}retryConfig?: RetryConfig;{% endif %}
  {% if enable_rate_limiting %}rateLimitConfig?: RateLimitConfig;{% endif %}
  logLevel?: LogLevel;
}

export class {{ api_name_class }} {
  private axiosInstance: AxiosInstance;
  private config: SDKConfig;
  private logger: Logger;
  {% if enable_rate_limiting %}private rateLimiter: PerEndpointRateLimiter;{% endif %}

  constructor(config: SDKConfig) {
    this.config = {
      timeout: 30000,
      {% if enable_retry_logic %}retryConfig: DEFAULT_RETRY_CONFIG,{% endif %}
      {% if enable_rate_limiting %}rateLimitConfig: DEFAULT_RATE_LIMIT_CONFIG,{% endif %}
      logLevel: 'info',
      ...config,
    };

    this.logger = new Logger({ level: this.config.logLevel });
    {% if enable_rate_limiting %}this.rateLimiter = new PerEndpointRateLimiter(this.config.rateLimitConfig);{% endif %}

    this.axiosInstance = axios.create({
      baseURL: this.config.baseURL,
      timeout: this.config.timeout,
      headers: this.getDefaultHeaders(),
    });

    this.setupInterceptors();
  }

  private getDefaultHeaders(): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      {% for key, value in global_headers.items() %}'{{ key }}': '{{ value }}',
      {% endfor %}
    };

    {% if auth_type == 'api_key' %}
    if (this.config.apiKey) {
      headers['X-API-Key'] = this.config.apiKey;
    }
    {% elif auth_type == 'bearer' %}
    if (this.config.bearerToken) {
      headers['Authorization'] = `Bearer ${this.config.bearerToken}`;
    }
    {% elif auth_type == 'oauth2' %}
    if (this.config.accessToken) {
      headers['Authorization'] = `Bearer ${this.config.accessToken}`;
    }
    {% elif auth_type == 'basic' %}
    if (this.config.username && this.config.password) {
      const credentials = Buffer.from(`${this.config.username}:${this.config.password}`).toString('base64');
      headers['Authorization'] = `Basic ${credentials}`;
    }
    {% endif %}

    return headers;
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.axiosInstance.interceptors.request.use(
      (config) => {
        this.logger.debug('Making request', {
          method: config.method,
          url: config.url,
          params: config.params,
        });
        return config;
      },
      (error) => {
        this.logger.error('Request error', error);
        return Promise.reject(error);
      }
    );

    // Response interceptor
    this.axiosInstance.interceptors.response.use(
      (response) => {
        this.logger.debug('Received response', {
          status: response.status,
          statusText: response.statusText,
        });
        return response;
      },
      (error) => {
        this.logger.error('Response error', {
          status: error.response?.status,
          statusText: error.response?.statusText,
          message: error.message,
        });
        return Promise.reject(error);
      }
    );
  }

  protected async request<T>(config: AxiosRequestConfig): Promise<T> {
    {% if enable_rate_limiting %}
    // Apply rate limiting
    const endpoint = `${config.method} ${config.url}`;
    await this.rateLimiter.acquire(endpoint);
    {% endif %}

    const makeRequest = async (): Promise<T> => {
      try {
        const response: AxiosResponse<T> = await this.axiosInstance.request(config);
        return response.data;
      } catch (error: any) {
        // Transform axios error to our error types
        if (error.response) {
          // HTTP error response
          const statusCode = error.response.status;
          const message = error.response.data?.message || error.response.statusText || 'Request failed';
          
          throw createErrorFromResponse(statusCode, message, {
            method: config.method,
            url: config.url,
          });
        } else if (error.request) {
          // Network error (no response received)
          throw new NetworkError(
            'Network error: No response received',
            error,
            {
              method: config.method,
              url: config.url,
            }
          );
        } else {
          // Other errors
          throw new NetworkError(error.message, error);
        }
      }
    };

    {% if enable_retry_logic %}
    // Apply retry logic with circuit breaker
    return circuitBreaker.execute(() =>
      retryWithBackoff(makeRequest, this.config.retryConfig)
    );
    {% else %}
    return makeRequest();
    {% endif %}
  }

  // Endpoint methods will be inserted here by the code generator
  {{ endpoint_methods }}
}
