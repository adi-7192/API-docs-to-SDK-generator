/**
 * Retry logic with exponential backoff for {{ api_name }} SDK
 * Generated by API SDK Generator
 */

import { RateLimitError } from './errors';

export interface RetryConfig {
  maxRetries: number;
  baseDelay: number; // milliseconds
  maxDelay: number; // milliseconds
  retryableStatusCodes: number[];
}

export const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: {{ retry_config.max_retries }},
  baseDelay: {{ retry_config.base_delay * 1000 }}, // Convert to milliseconds
  maxDelay: {{ retry_config.max_delay * 1000 }}, // Convert to milliseconds
  retryableStatusCodes: {{ retry_config.retryable_status_codes | tojson }},
};

/**
 * Retry a function with exponential backoff
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  config: RetryConfig = DEFAULT_RETRY_CONFIG,
  attempt: number = 0
): Promise<T> {
  try {
    return await fn();
  } catch (error: any) {
    // Check if we should retry
    const shouldRetry = shouldRetryError(error, config);
    const hasRetriesLeft = attempt < config.maxRetries;

    if (!shouldRetry || !hasRetriesLeft) {
      throw error;
    }

    // Calculate delay with exponential backoff and jitter
    const delay = calculateDelay(attempt, config, error);

    // Log retry attempt (if logger is available)
    console.log(
      `Retry attempt ${attempt + 1}/${config.maxRetries} after ${delay}ms delay`
    );

    // Wait before retrying
    await sleep(delay);

    // Retry
    return retryWithBackoff(fn, config, attempt + 1);
  }
}

/**
 * Determine if an error should be retried
 */
function shouldRetryError(error: any, config: RetryConfig): boolean {
  // Network errors should be retried
  if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {
    return true;
  }

  // Check if status code is retryable
  if (error.statusCode && config.retryableStatusCodes.includes(error.statusCode)) {
    return true;
  }

  return false;
}

/**
 * Calculate delay with exponential backoff and jitter
 */
function calculateDelay(
  attempt: number,
  config: RetryConfig,
  error: any
): number {
  // Check for Retry-After header (for rate limiting)
  if (error instanceof RateLimitError && error.retryAfter) {
    return error.retryAfter * 1000; // Convert seconds to milliseconds
  }

  // Exponential backoff: baseDelay * 2^attempt
  const exponentialDelay = config.baseDelay * Math.pow(2, attempt);

  // Add jitter (random value between 0 and 1000ms)
  const jitter = Math.random() * 1000;

  // Calculate total delay
  const totalDelay = exponentialDelay + jitter;

  // Cap at maxDelay
  return Math.min(totalDelay, config.maxDelay);
}

/**
 * Sleep for specified milliseconds
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Circuit breaker state
 */
class CircuitBreaker {
  private failureCount: number = 0;
  private lastFailureTime: number = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  
  private readonly failureThreshold: number = 3;
  private readonly resetTimeout: number = 60000; // 60 seconds

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      // Check if we should try half-open
      if (Date.now() - this.lastFailureTime > this.resetTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}

export const circuitBreaker = new CircuitBreaker();
